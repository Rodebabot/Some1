import os
import shutil

# List of source folders and their corresponding destination folders
source_folders = ['source_folder1', 'source_folder2', 'source_folder3']
destination_folders = ['destination_folder1', 'destination_folder2', 'destination_folder3']

# Iterate through the source-destination pairs
for source_folder, destination_folder in zip(source_folders, destination_folders):
    source_path = source_folder
    destination_path = destination_folder

    # List all files in the source folder
    files_to_copy = os.listdir(source_path)

    # Copy each file to the corresponding destination folder if it doesn't already exist
    for file_name in files_to_copy:
        source_file_path = os.path.join(source_path, file_name)
        destination_file_path = os.path.join(destination_path, 











import pandas as pd
import win32com.client
import os
from datetime import datetime

# Load the Excel file into a pandas DataFrame
excel_file = 'path_to_your_excel_file.xlsx'
df = pd.read_excel(excel_file)

# Connect to Outlook
outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")

# Replace 'SubfolderName' with the name of the subfolder where you want to check for emails
inbox = outlook.GetDefaultFolder(6).Folders['SubfolderName'].Items

# Limit the loop to repeat for a maximum of 200 times
max_iterations = 200

# Initialize a counter for iterations
iterations = 0

# Loop for a maximum of 200 times
while iterations < max_iterations:
    # Loop through each email in the subfolder
    for email in inbox:
        try:
            sender = email.SenderEmailAddress
        except Exception as e:
            print(f"Error getting sender email address: {str(e)}")
            continue  # Skip this email and continue to the next one

        subject = email.Subject
        received_date = email.ReceivedTime.date()
        today = datetime.today().date()

        # Check if the email was received today and if the combination of sender and subject exists in the DataFrame
        if received_date == today and not df[(df['SenderName'] == sender) & (df['Subject'] == subject)].empty:
            # Get the folder locations from the matched row and split them by comma
            folder_locations = df[(df['SenderName'] == sender) & (df['Subject'] == subject)].iloc[0]['FolderLocation'].split(',')

            # Save the attachments in each corresponding location with dd-mm-yyyy timestamp
            timestamp = datetime.now().strftime("%d-%m-%Y")
            for folder_location in folder_locations:
                folder_location = folder_location.strip()  # Remove leading/trailing whitespace
                for attachment in email.Attachments:
                    attachment_filename = os.path.join(folder_location, f"{timestamp}_{attachment.FileName}")
                    attachment.SaveAsFile(attachment_filename)
                    print(f"Attachment '{attachment.FileName}' saved to '{attachment_filename}'")

    # Increment the iterations counter
    iterations += 1

print(f"Completed {iterations} iterations.")







import pandas as pd
import win32com.client
import os
from datetime import datetime

# Load the Excel file into a pandas DataFrame
excel_file = 'path_to_your_excel_file.xlsx'
df = pd.read_excel(excel_file)

# Connect to Outlook
outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")

# Replace 'SubfolderName' with the name of the subfolder where you want to check for emails
inbox = outlook.GetDefaultFolder(6).Folders['SubfolderName'].Items

# Initialize counters
emails_processed = 0
iterations = 0

# Set limits
max_emails_to_process = 6
max_iterations = 200

# Loop through each email in the subfolder
for email in inbox:
    try:
        sender = email.SenderEmailAddress
    except Exception as e:
        print(f"Error getting sender email address: {str(e)}")
        continue  # Skip this email and continue to the next one

    subject = email.Subject
    received_date = email.ReceivedTime.date()
    today = datetime.today().date()

    # Check if the email was received today and if the combination of sender and subject exists in the DataFrame
    if received_date == today and not df[(df['SenderName'] == sender) & (df['Subject'] == subject)].empty:
        # Get the folder locations from the matched row and split them by comma
        folder_locations = df[(df['SenderName'] == sender) & (df['Subject'] == subject)].iloc[0]['FolderLocation'].split(',')

        # Save the attachments in each corresponding location with dd-mm-yyyy timestamp
        timestamp = datetime.now().strftime("%d-%m-%Y")
        for folder_location in folder_locations:
            folder_location = folder_location.strip()  # Remove leading/trailing whitespace
            for attachment in email.Attachments:
                attachment_filename = os.path.join(folder_location, f"{timestamp}_{attachment.FileName}")
                attachment.SaveAsFile(attachment_filename)
                print(f"Attachment '{attachment.FileName}' saved to '{attachment_filename}'")

        # Increment the emails processed counter
        emails_processed += 1











import os

# Specify the folder path
folder_path = '/path/to/your/folder/'

# Iterate through files in the folder
for filename in os.listdir(folder_path):
    # Check if the file name contains repeated suffixes
    if filename.count('-SOD') > 1:
        new_filename = filename.replace('-SOD', '', 1)
    elif filename.count('-MOD') > 1:
        new_filename = filename.replace('-MOD', '', 1)
    elif filename.count('-EOD') > 1:
        new_filename = filename.replace('-EOD', '', 1)
    elif filename.count('-FINAL') > 1:
        new_filename = filename.replace('-FINAL', '', 1)
    else:
        new_filename = filename  # No repeated suffixes found, keep the original name
    
    # Rename the file
    os.rename(os.path.join(folder_path, filename), os.path.join(folder_path, new_filename))


        # Check if the maximum number of emails has been reached
        if emails_processed >= max_emails_to_process:
            break  # Exit the loop

    # Increment the iterations counter
    iterations += 1

    # Check if the maximum number of iterations has been reached
    if iterations >= max_iterations:
        break  # Exit the loop

print(f"Processed {emails_processed} emails in {iterations} iterations.")
