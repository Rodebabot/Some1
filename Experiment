import os

def delete_files_in_directories(directory_list):
    for directory in directory_list:
        if os.path.exists(directory):
            for root, _, files in os.walk(directory):
                for file in files:
                    file_path = os.path.join(root, file)
                    os.remove(file_path)
                    print(f"Deleted: {file_path}")
        else:
            print(f"Directory not found: {directory}")

# Example usage:
directories_to_clear = ['/path/to/directory1', '/path/to/directory2']
delete_files_in_directories(directories_to_clear)








import pandas as pd
import win32com.client
import os
from datetime import datetime
import time  # Import the time module

# Load the Excel file into a pandas DataFrame
excel_file = 'path_to_your_excel_file.xlsx'
df = pd.read_excel(excel_file)

# Connect to Outlook
outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")

# Replace 'SubfolderName' with the name of the subfolder where you want to check for emails
inbox = outlook.GetDefaultFolder(6).Folders['SubfolderName'].Items

# Set the maximum number of emails to process
max_emails_to_process = 6

# Set the maximum execution time in seconds (4 minutes = 240 seconds)
max_execution_time = 240

# Initialize counters and timer
emails_processed = 0
start_time = time.time()

# Loop through each email in the subfolder
for email in inbox:
    try:
        sender = email.SenderEmailAddress
    except Exception as e:
        print(f"Error getting sender email address: {str(e)}")
        continue  # Skip this email and continue to the next one

    subject = email.Subject
    received_date = email.ReceivedTime.date()
    today = datetime.today().date()

    # Check if the email was received today and if the combination of sender and subject exists in the DataFrame
    if received_date == today and not df[(df['SenderName'] == sender) & (df['Subject'] == subject)].empty:
        # Get the folder locations from the matched row and split them by comma
        folder_locations = df[(df['SenderName'] == sender) & (df['Subject'] == subject)].iloc[0]['FolderLocation'].split(',')

        # Save the attachments in each corresponding location with dd-mm-yyyy timestamp
        timestamp = datetime.now().strftime("%d-%m-%Y")
        for folder_location in folder_locations:
            folder_location = folder_location.strip()  # Remove leading/trailing whitespace
            for attachment in email.Attachments:
                attachment_filename = os.path.join(folder_location, f"{timestamp}_{attachment.FileName}")
                attachment.SaveAsFile(attachment_filename)
                print(f"Attachment '{attachment.FileName}' saved to '{attachment_filename}'")

        # Increment the emails processed counter
        emails_processed += 1

        # Check if the maximum number of emails or execution time limit has been reached
        if emails_processed >= max_emails_to_process or (time.time() - start_time) >= max_execution_time:
            break  # Exit the loop

print(f"Processed {emails_processed} emails.")
