import pandas as pd

def create_combinations(data):
  """
  This function takes a pandas DataFrame and creates new rows for every combination
  of columns 1, 2, 4, and 5 with different CLS values (C and D are added if missing).

  Args:
      data: A pandas DataFrame containing the original data.

  Returns:
      A new pandas DataFrame with the additional rows for all combinations and CLS values.
  """
  # Select columns for combinations
  cols = ["Entity", "Counterparty Name", "CCY", "Value Date", "Net"]
  combinations = data[cols].drop_duplicates()

  # Define missing CLS values
  missing_cls = ["C", "D"]

  # Iterate through combinations and create new rows
  new_data = []
  for index, row in combinations.iterrows():
    # Extract data for current combination
    entity = row["Entity"]
    counterparty = row["Counterparty Name"]
    ccy = row["CCY"]
    value_date = row["Value Date"]
    net_amount = row["Net"]

    # Filter data for current combination
    filtered_data = data[(data["Entity"] == entity) & 
                         (data["Counterparty Name"] == counterparty) & 
                         (data["CCY"] == ccy) & 
                         (data["Value Date"] == value_date)]

    # Get existing CLS values from filtered data
    existing_cls = filtered_data["CLS"].tolist()

    # Add rows for missing CLS values
    for cls in missing_cls:
      if cls not in existing_cls:
        new_data.append({
            "Entity": entity,
            "Counterparty Name": counterparty,
            "CLS": cls,
            "CCY": ccy,
            "Value Date": value_date,
            "Net": 0.0  # Set net amount to 0 for missing CLS
        })

    # Add rows for each existing CLS (if present)
    for cls in existing_cls:
      new_data.append({
          "Entity": entity,
          "Counterparty Name": counterparty,
          "CLS": cls,
          "CCY": ccy,
          "Value Date": value_date,
          "Net": filtered_data[filtered_data["CLS"] == cls]["Net"].values[0]
      })

  # Combine original data with new rows
  return pd.concat([data, pd.DataFrame(new_data)], ignore_index=True)

# Assuming you have your data in a pandas DataFrame called 'data'
new_data = create_combinations(data.copy())  # Operate on a copy to avoid modifying original data

# Print the new DataFrame with all combinations and CLS values
print(new_data)
