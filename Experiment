import os
import shutil

# List of source folders and their corresponding destination folders
source_folders = ['source_folder1', 'source_folder2', 'source_folder3']
destination_folders = ['destination_folder1', 'destination_folder2', 'destination_folder3']

# Iterate through the source-destination pairs
for source_folder, destination_folder in zip(source_folders, destination_folders):
    source_path = source_folder
    destination_path = destination_folder

    # List all files in the source folder
    files_to_copy = os.listdir(source_path)

    # Copy each file to the corresponding destination folder if it doesn't already exist
    for file_name in files_to_copy:
        source_file_path = os.path.join(source_path, file_name)
        destination_file_path = os.path.join(destination_path, file_name)

        # Check if the file already exists in the destination folder
        if not os.path.exists(destination_file_path):
            # Use shutil.copy() to copy the file
            shutil.copy(source_file_path, destination_file_path)






import pandas as pd
import win32com.client
import os
from datetime import datetime, timedelta

# Load the Excel file into a pandas DataFrame
excel_file = 'path_to_your_excel_file.xlsx'
df = pd.read_excel(excel_file)

# Connect to Outlook
outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")

# Replace 'SubfolderName' with the name of the subfolder where you want to check for emails
inbox = outlook.GetDefaultFolder(6).Folders['SubfolderName'].Items

# Set the maximum number of emails to process
max_emails_to_process = 6

# Set the maximum execution time in seconds (4 minutes = 240 seconds)
max_execution_time_seconds = 240

# Initialize counters and start time
emails_processed = 0
start_time = datetime.now()

# Loop through each email in the subfolder
for email in inbox:
    try:
        sender = email.SenderEmailAddress
    except Exception as e:
        print(f"Error getting sender email address: {str(e)}")
        continue  # Skip this email and continue to the next one

    subject = email.Subject
    received_date = email.ReceivedTime.date()
    today = datetime.today().date()

    # Check if the email was received today and if the combination of sender and subject exists in the DataFrame
    if received_date == today and not df[(df['SenderName'] == sender) & (df['Subject'] == subject)].empty:
        # Get the folder locations from the matched row and split them by comma
        folder_locations = df[(df['SenderName'] == sender) & (df['Subject'] == subject)].iloc[0]['FolderLocation'].split(',')

        # Save the attachments in each corresponding location with dd-mm-yyyy timestamp
        timestamp = datetime.now().strftime("%d-%m-%Y")
        for folder_location in folder_locations:
            folder_location = folder_location.strip()  # Remove leading/trailing whitespace
            for attachment in email.Attachments:
                attachment_filename = os.path.join(folder_location, f"{timestamp}_{attachment.FileName}")
                attachment.SaveAsFile(attachment_filename)
                print(f"Attachment '{attachment.FileName}' saved to '{attachment_filename}'")

        # Increment the emails processed counter
        emails_processed += 1

        # Check if the maximum number of emails or execution time limit has been reached
        elapsed_time = datetime.now() - start_time
        if emails_processed >= max_emails_to_process or elapsed_time.total_seconds() >= max_execution_time_seconds:
            break  # Exit the loop

print(f"Processed {emails_processed} emails.")







import pandas as pd
import win32com.client
import os
from datetime import datetime
from timeout_decorator import timeout

# Load the Excel file into a pandas DataFrame
excel_file = 'path_to_your_excel_file.xlsx'
df = pd.read_excel(excel_file)

# Connect to Outlook
outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")

# Replace 'SubfolderName' with the name of the subfolder where you want to check for emails
inbox = outlook.GetDefaultFolder(6).Folders['SubfolderName'].Items

# Set the maximum number of emails to process
max_emails_to_process = 6

# Initialize counters
emails_processed = 0

# Define a function to process emails
@timeout(240)  # Set the maximum execution time to 240 seconds (4 minutes)
def process_email(email):
    nonlocal emails_processed

    try:
        sender = email.SenderEmailAddress
    except Exception as e:
        print(f"Error getting sender email address: {str(e)}")
        return

    subject = email.Subject
    received_date = email.ReceivedTime.date()
    today = datetime.today().date()

    # Check if the email was received today and if the combination of sender and subject exists in the DataFrame
    if received_date == today and not df[(df['SenderName'] == sender) & (df['Subject'] == subject)].empty:
        # Get the folder locations from the matched row and split them by comma
        folder_locations = df[(df['SenderName'] == sender) & (df['Subject'] == subject)].iloc[0]['FolderLocation'].split(',')

        # Save the attachments in each corresponding location with dd-mm-yyyy timestamp
        timestamp = datetime.now().strftime("%d-%m-%Y")
        for folder_location in folder_locations:
            folder_location = folder_location.strip()  # Remove leading/trailing whitespace
            for attachment in email.Attachments:
                attachment_filename = os.path.join(folder_location, f"{timestamp}_{attachment.FileName}")
                attachment.SaveAsFile(attachment_filename)
                print(f"Attachment '{attachment.FileName}' saved to '{attachment_filename}'")

        # Increment the emails processed counter
        emails_processed += 1

# Loop through each email in the subfolder
for email in inbox:
    try:
        process_email(email)
    except TimeoutError:
        print("Execution time limit reached. Exiting.")
        break

    # Check if the maximum number of emails has been reached
    if emails_processed >= max_emails_to_process:
        print("Maximum number of emails processed. Exiting.")
        break

print(f"Processed {emails_processed} emails.")
