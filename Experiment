import os
import datetime

folder_path = "/path/to/your/folder"
files = os.listdir(folder_path)
files.sort()

if files:
    first_file = files[0]
    last_file = files[-1]
    today = datetime.datetime.today()

    for i, file_name in enumerate(files):
        file_datetime = datetime.datetime.strptime(file_name, "%Y-%m-%d_%H-%M")
        delta = (today - file_datetime).days

        if delta == 0:
            suffix = "Sod"
        elif delta == 1:
            suffix = "Mod"
        elif delta == 2:
            suffix = "Eod"
        elif file_name == last_file:
            suffix = "Final"
        else:
            suffix = ""

        new_file_name = f"{file_name}_{suffix}"
        os.rename(os.path.join(folder_path, file_name), os.path.join(folder_path, new_file_name))










import os
import datetime

folder_path = "/path/to/your/folder"
files = os.listdir(folder_path)
files.sort()

if files:
    first_file = files[0]
    last_file = files[-1]
    today = datetime.datetime.today()

    for i, file_name in enumerate(files):
        file_name_without_extension, file_extension = os.path.splitext(file_name)
        file_datetime = datetime.datetime.strptime(file_name_without_extension, "%Y-%m-%d_%H-%M")
        delta = (today - file_datetime).days

        if delta == 0:
            suffix = "Sod"
        elif delta == 1:
            suffix = "Mod"
        elif delta == 2:
            suffix = "Eod"
        elif file_name == last_file:
            suffix = "Final"
        else:
            suffix = ""

        new_file_name = f"{file_name_without_extension}_{suffix}{file_extension}"
        os.rename(os.path.join(folder_path, file_name), os.path.join(folder_path, new_file_name))












import os
import datetime

folder_path = "/path/to/your/folder"
files = os.listdir(folder_path)

date_format = "%Y%m%d%H%M%S"
file_datetime_list = []

for file_name in files:
    date_time_part = file_name[:14]  # Extract the first 14 characters for the datetime part
    try:
        file_datetime = datetime.datetime.strptime(date_time_part, date_format)
        file_datetime_list.append(file_datetime)
    except ValueError:
        pass

file_datetime_list.sort()

today = datetime.datetime.now().replace(microsecond=0)
suffixes = ["Sod", "Mod", "Eod", "Final"]

for i, file_datetime in enumerate(file_datetime_list):
    delta = (today - file_datetime).days

    if delta == 0:
        suffix = suffixes[0]
    elif delta == 1:
        suffix = suffixes[1]
    elif delta == 2:
        suffix = suffixes[2]
    elif delta == 3:
        suffix = suffixes[3]
    else:
        suffix = ""

    old_file_name = files[i]
    file_name_without_extension, file_extension = os.path.splitext(old_file_name)
    new_file_name = f"{file_name_without_extension}_{suffix}{file_extension}"

    os.rename(os.path.join(folder_path, old_file_name), os.path.join(folder_path, new_file_name))



























import os

folder_path = "/path/to/your/folder"
files = os.listdir(folder_path)

if len(files) == 1:
    old_file_name = files[0]
    new_file_name = f"SOD_{old_file_name}"
    os.rename(os.path.join(folder_path, old_file_name), os.path.join(folder_path, new_file_name))
elif len(files) == 2:
    for file_name in files:
        if "SOD" not in file_name:
            old_file_name = file_name
            new_file_name = f"MOD_{old_file_name}"
            os.rename(os.path.join(folder_path, old_file_name), os.path.join(folder_path, new_file_name))
            break
elif len(files) == 3:
    suffix = None
    for file_name in files:
        if "SOD" not in file_name and "MOD" not in file_name:
            old_file_name = file_name
            new_file_name = f"EOD_{old_file_name}"
            os.rename(os.path.join(folder_path, old_file_name), os.path.join(folder_path, new_file_name))
            break





import pandas as pd
from fbprophet import Prophet

# Load data from Excel
data = pd.read_excel('your_excel_file.xlsx')

# Preprocess data
data.rename(columns={'Date_Column_Name': 'ds', 'Volume_Column_Name': 'y'}, inplace=True)

# Initialize and fit the Prophet model
model = Prophet()
model.fit(data)

# Create future dataframe for 12 months ahead
future = model.make_future_dataframe(periods=12, freq='M')

# Predict the next 12 months
forecast = model.predict(future)

# Extract the next 12 months and their forecasted volumes
next_12_months_forecast = forecast[['ds', 'yhat']].tail(12)

# Rename the columns
next_12_months_forecast.rename(columns={'ds': 'Next 12 Months', 'yhat': 'Forecasted Volume'}, inplace=True)

print(next_12_months_forecast)



















import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression

# Load the Excel sheet into a pandas DataFrame
excel_file = 'your_file.xlsx'
df = pd.read_excel(excel_file)

# Extract 'Volume' and 'Exceptions' columns
volume = df['Volume'].values
exceptions = df['Exceptions'].values

# Calculate correlation
correlation = np.corrcoef(volume, exceptions)[0, 1]

# Reshape the data for regression
X = volume.reshape(-1, 1)
y = exceptions

# Create a Linear Regression model
regressor = LinearRegression()
regressor.fit(X, y)

# Get the regression equation coefficients
slope = regressor.coef_[0]
intercept = regressor.intercept_

# Create the regression equation string
regression_equation = f"Exceptions = {slope:.2f} * Volume + {intercept:.2f}"

print("Correlation:", correlation)
print("Regression Equation:", regression_equation)















import pandas as pd
import numpy as np
import dash
import dash_core_components as dcc
import dash_html_components as html
from dash.dependencies import Input, Output
from statsmodels.tsa.statespace.sarimax import SARIMAX
from datetime import datetime, timedelta

# Load your data into a pandas DataFrame
# Make sure the date column is named 'ds' and the volume columns are named 'y1', 'y2', 'y3', and 'y4'
data = pd.read_csv('your_data.csv')
data['ds'] = pd.to_datetime(data['ds'])
data.set_index('ds', inplace=True)

# List of volume columns
volume_columns = ['y1', 'y2', 'y3', 'y4']

# Create a Dash app
app = dash.Dash(__name__)

app.layout = html.Div([
    dcc.Dropdown(
        id='volume-dropdown',
        options=[{'label': column, 'value': column} for column in volume_columns],
        value='y1',  # Default to the first volume column
        multi=True  # Allow selecting multiple columns
    ),
    dcc.Graph(id='volume-graph'),
    html.Div(id='predicted-table')
])

@app.callback(
    [Output('volume-graph', 'figure'),
     Output('predicted-table', 'children')],
    [Input('volume-dropdown', 'value')]
)
def update_graph(selected_columns):
    graphs = []
    tables = []

    for column in selected_columns:
        # Prepare data for SARIMA model
        y = data[column]

        # Initialize and fit the SARIMA model on the full data
        order = (1, 1, 1)  # You can adjust the order based on your data
        seasonal_order = (1, 1, 1, 12)  # Considering monthly seasonality
        sarima_model = SARIMAX(y, order=order, seasonal_order=seasonal_order)
        sarima_result = sarima_model.fit(disp=False)

        # Forecast the next 12 months
        last_date = y.index[-1]
        next_12_months = pd.date_range(start=last_date + pd.DateOffset(months=1), periods=12, freq='M')
        forecast = sarima_result.get_forecast(steps=12)

        # Create a table of predicted volume for the next 12 months
        predicted_volumes = forecast.predicted_mean.reset_index()
        predicted_volumes.columns = ['Month', 'Predicted Volume']
        predicted_volumes['Month'] = next_12_months
        predicted_volumes.set_index('Month', inplace=True)

        # Create a line graph for the selected column
        graphs.append({
            'data': [
                {'x': y.index, 'y': y, 'mode': 'lines', 'name': f'Actual Data ({column})'},
                {'x': predicted_volumes.index, 'y': predicted_volumes['Predicted Volume'], 'mode': 'lines', 'name': f'Predicted Data ({column})'}
            ],
            'layout': {
                'title': f'Actual vs Predicted Volume ({column})',
                'xaxis': {'title': 'Date'},
                'yaxis': {'title': 'Volume'}
            }
        })

        # Create a table for the predicted volume
        tables.append(html.Div([
            html.H4(f'Predicted Volume Table ({column})'),
            html.Table([
                html.Tr([html.Th('Month'), html.Th('Predicted Volume')]),
                *[html.Tr([html.Td(index.strftime('%B %Y')), html.Td(round(value, 2))]) for index, value in predicted_volumes.iterrows()]
            ])
        ]))

    return graphs, tables

if __name__ == '__main__':
    app.run_server(debug=True)






import pandas as pd
import numpy as np
import dash
import dash_core_components as dcc
import dash_html_components as html
from dash.dependencies import Input, Output
from statsmodels.tsa.statespace.sarimax import SARIMAX
from datetime import datetime, timedelta

# Load your data into a pandas DataFrame
# Make sure the date column is named 'ds' and the volume columns are named 'y1', 'y2', 'y3', and 'y4'
data = pd.read_csv('your_data.csv')
data['ds'] = pd.to_datetime(data['ds'])
data.set_index('ds', inplace=True)

# List of volume columns
volume_columns = ['y1', 'y2', 'y3', 'y4']

# Create a Dash app
app = dash.Dash(__name__)

app.layout = html.Div([
    dcc.Dropdown(
        id='volume-dropdown',
        options=[{'label': column, 'value': column} for column in volume_columns],
        value=['y1'],  # Default to the first volume column
        multi=True  # Allow selecting multiple columns
    ),
    dcc.Graph(id='volume-graph'),
    html.Div(id='predicted-table')
])

@app.callback(
    [Output('volume-graph', 'figure'),
     Output('predicted-table', 'children')],
    [Input('volume-dropdown', 'value')]
)
def update_graph(selected_columns):
    graphs = []
    tables = []

    for column in selected_columns:
        # Prepare data for SARIMA model
        y = data[column]

        # Initialize and fit the SARIMA model on the full data
        order = (1, 1, 1)  # You can adjust the order based on your data
        seasonal_order = (1, 1, 1, 12)  # Considering monthly seasonality
        sarima_model = SARIMAX(y, order=order, seasonal_order=seasonal_order)
        sarima_result = sarima_model.fit(disp=False)

        # Forecast the next 12 months
        last_date = y.index[-1]
        next_12_months = pd.date_range(start=last_date + pd.DateOffset(months=1), periods=12, freq='M')
        forecast = sarima_result.get_forecast(steps=12)

        # Create a table of predicted volume for the next 12 months
        predicted_volumes = forecast.predicted_mean.reset_index()
        predicted_volumes.columns = ['Month', 'Predicted Volume']
        predicted_volumes['Month'] = next_12_months
        predicted_volumes.set_index('Month', inplace=True)

        # Create a line graph for the selected column
        graphs.append({
            'data': [
                {'x': y.index, 'y': y, 'mode': 'lines', 'name': f'Actual Data ({column})'},
                {'x': predicted_volumes.index, 'y': predicted_volumes['Predicted Volume'], 'mode': 'lines', 'name': f'Predicted Data ({column})'}
            ],
            'layout': {
                'title': f'Actual vs Predicted Volume ({column})',
                'xaxis': {'title': 'Date'},
                'yaxis': {'title': 'Volume'}
            }
        })











import pandas as pd
import numpy as np
import dash
import dash_core_components as dcc
import dash_html_components as html
from dash.dependencies import Input, Output
from statsmodels.tsa.statespace.sarimax import SARIMAX
from datetime import datetime, timedelta

# Load your data into a pandas DataFrame
# Make sure the date column is named 'ds' and the volume columns are named 'y1', 'y2', 'y3', and 'y4'
data = pd.read_csv('your_data.csv')
data['ds'] = pd.to_datetime(data['ds'])
data.set_index('ds', inplace=True)

# List of volume columns
volume_columns = ['y1', 'y2', 'y3', 'y4']

# Create a Dash app
app = dash.Dash(__name__)

app.layout = html.Div([
    dcc.Dropdown(
        id='volume-dropdown',
        options=[{'label': column, 'value': column} for column in volume_columns],
        value=['y1'],  # Default to the first volume column
        multi=True  # Allow selecting multiple columns
    ),
    dcc.Graph(id='volume-graph'),
    html.Div(id='predicted-table')
])

@app.callback(
    [Output('volume-graph', 'figure'),
     Output('predicted-table', 'children')],
    [Input('volume-dropdown', 'value')]
)
def update_graph(selected_columns):
    graphs = []
    tables = []

    for column in selected_columns:
        # Prepare data for SARIMA model
        y = data[column]

        # Initialize and fit the SARIMA model on the full data
        order = (1, 1, 1)  # You can adjust the order based on your data
        seasonal_order = (1, 1, 1, 12)  # Considering monthly seasonality
        sarima_model = SARIMAX(y, order=order, seasonal_order=seasonal_order)
        sarima_result = sarima_model.fit(disp=False)

        # Forecast the next 12 months
        last_date = y.index[-1]
        next_12_months = pd.date_range(start=last_date + pd.DateOffset(months=1), periods=12, freq='M')
        forecast = sarima_result.get_forecast(steps=12)

        # Create a table of predicted volume for the next 12 months
        predicted_volumes = forecast.predicted_mean.reset_index()
        predicted_volumes.columns = ['Month', f'Predicted Volume ({column})']
        predicted_volumes['Month'] = next_12_months
        predicted_volumes.set_index('Month', inplace=True)

        # Create a line graph for the selected column
        graphs.append({
            'data': [
                {'x': y.index, 'y': y, 'mode': 'lines', 'name': f'Actual Data ({column})'},
                {'x': predicted_volumes.index, 'y': predicted_volumes[f'Predicted Volume ({column})'], 'mode': 'lines', 'name': f'Predicted Data ({column})'}
            ],
            'layout': {
                'title': f'Actual vs Predicted Volume ({column})',
                'xaxis': {'title': 'Date'},
                'yaxis': {'title': 'Volume'}
            }
        })

        # Append the table for the predicted volume
        tables.append(html.Div([
            html.H4(f'Predicted Volume Table ({column})'),
            html.Table([
                html.Tr([html.Th('Month'), html.Th(f'Predicted Volume ({column})')]),
                *[html.Tr([html.Td(index.strftime('%B %Y')), html.Td(round(value, 2))]) for index, value in predicted_volumes.iterrows()]
            ])
        ]))

    return graphs, tables

if __name__ == '__main__':
    app.run_server(debug=True)



        # Create a table for the predicted volume
        tables.append(html.Div([
            html.H4(f'Predicted Volume Table ({column})'),
            html.Table([
                html.Tr([html.Th('Month'), html.Th('Predicted Volume')]),
                *[html.Tr([html.Td(index.strftime('%B %Y')), html.Td(round(value, 2))]) for index, value in predicted_volumes.iterrows()]
            ])
        ]))

    return graphs, tables

if __name__ == '__main__':
    app.run_server(debug=True)
