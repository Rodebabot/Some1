import pandas as pd

def create_combinations(data):
  """
  This function takes a pandas DataFrame and creates new rows for every combination
  of columns 1, 2, 4, and 5 with different CLS values (C and D are added if missing).

  Args:
      data: A pandas DataFrame containing the original data.

  Returns:
      A new pandas DataFrame with the additional rows for all combinations and CLS values.
  """
  # Select columns for combinations
  cols = ["Entity", "Counterparty Name", "Value Date", "Net [złówka symbol]"]
  combinations = data[cols].drop_duplicates()

  # Define missing CLS values
  missing_cls = ["C", "D"]

  # Iterate through combinations and create new rows
  new_data = []
  for index, row in combinations.iterrows():
    # Extract data for current combination
    entity = row["Entity"]
    counterparty = row["Counterparty Name"]
    value_date = row["Value Date"]
    net_amount = row["Net [złówka symbol]"]

    # Get existing CLS value from original data
    existing_cls = data[(data["Entity"] == entity) & 
                         (data["Counterparty Name"] == counterparty) & 
                         (data["Value Date"] == value_date)]["CLS"]

    # Add rows for missing CLS values
    for cls in missing_cls:
      if cls not in existing_cls.values:
        new_data.append({
            "Entity": entity,
            "Counterparty Name": counterparty,
            "CLS": cls,
            "Value Date": value_date,
            "Net [złówka symbol]": 0.0  # Set net amount to 0 for missing CLS
        })

    # Add row for existing CLS (if present)
    if len(existing_cls) > 0:
      new_data.append({
          "Entity": entity,
          "Counterparty Name": counterparty,
          "CLS": existing_cls.values[0],  # Assuming only one existing CLS
          "Value Date": value_date,
          "Net [złówka symbol]": net_amount
      })

  # Combine original data with new rows
  return pd.concat([data, pd.DataFrame(new_data)], ignore_index=True)

# Assuming you have your data in a pandas DataFrame called 'data'
new_data = create_combinations(data.copy())  # Operate on a copy to avoid modifying original data

# Print the new DataFrame with all combinations and CLS values
print(new_data)
