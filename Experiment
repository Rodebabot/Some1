import os

def delete_files_in_directories(directory_list):
    for directory in directory_list:
        if os.path.exists(directory):
            for root, _, files in os.walk(directory):
                for file in files:
                    file_path = os.path.join(root, file)
                    os.remove(file_path)
                    print(f"Deleted: {file_path}")
        else:
            print(f"Directory not found: {directory}")

# Example usage:
directories_to_clear = ['/path/to/directory1', '/path/to/directory2']
delete_files_in_directories(directories_to_clear)








import pandas as pd
import win32com.client
import os
from datetime import datetime
import time  # Import the time module

# Load the Excel file into a pandas DataFrame
excel_file = 'path_to_your_excel_file.xlsx'
df = pd.read_excel(excel_file)

# Connect to Outlook
outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")

# Replace 'SubfolderName' with the name of the subfolder where you want to check for emails
inbox = outlook.GetDefaultFolder(6).Folders['SubfolderName'].Items

# Set the maximum number of emails to process
max_emails_to_process = 6

# Set the maximum execution time in seconds (4 minutes = 240 seconds)
max_execution_time = 240

# Initialize counters and timer
emails_processed = 0
start_time = time.time()

# Loop through each email in the subfolder
for email in inbox:
    try:
        sender = email.SenderEmailAddress
    except Exception as e:
        print(f"Error getting sender email address: {str(e)}")
        continue  # Skip this email and continue to the next one

    subject = email.Subject
    received_date = email.ReceivedTime.date()
    today = datetime.today().date()

    # Check if the email was received today and if the combination of sender and subject exists in the DataFrame
    if received_date == today and not df[(df['SenderName'] == sender) & (df['Subject'] == subject)].empty:
        # Get the folder locations from the matched row and split them by comma
        folder_locations = df[(df['SenderName'] == sender) & (df['Subject'] == subject)].iloc[0]['FolderLocation'].split(',')

        # Save the attachments in each corresponding location with dd-mm-yyyy timestamp
        timestamp = datetime.now().strftime("%d-%m-%Y")
        for folder_location in folder_locations:
            folder_location = folder_location.strip()  # Remove leading/trailing whitespace
            for attachment in email.Attachments:
                attachment_filename = os.path.join(folder_location, f"{timestamp}_{attachment.FileName}")
                attachment.SaveAsFile(attachment_filename)
                print(f"Attachment '{attachment.FileName}' saved to '{attachment_filename}'")

        # Increment the emails processed counter
        emails_processed += 1

        # Check if the maximum number of emails or execution time limit has been reached
        if emails_processed >= max_emails_to_process or (time.time() - start_time) >= max_execution_time:
            break  # Exit the loop

print(f"Processed {emails_processed} emails.")





**Day 1: Introduction to Python**
- Session 1: Welcome to Python and its importance.
- Session 2: Setting up Python on your computer.

**Days 2-5: Python Basics**
- Session 3-6: Variables, data types, and basic operations.
- Session 7-10: Control structures (if statements, loops).

**Days 6-9: Functions and Modules**
- Session 11-14: Understanding functions and creating your own.
- Session 15-18: Introduction to Python modules and libraries.

**Days 10-13: Data Structures**
- Session 19-22: Lists and tuples.
- Session 23-26: Dictionaries and sets.

**Days 14-17: File Handling and Exception Handling**
- Session 27-30: Reading and writing files.
- Session 31-34: Handling errors with exception handling.

**Days 18-20: Mini Projects**
- Session 35-37: Building simple Python projects to apply what you've learned.
- Session 38-40: Final projects and Q&A sessions.

Throughout the training, encourage participants to practice what they learn by working on small exercises and projects outside of the training sessions. Provide additional resources like online tutorials and documentation to help them deepen their understanding of Python.

Remember to adapt the curriculum based on your participants' progress and needs, and allow time for questions and discussions during each session.
